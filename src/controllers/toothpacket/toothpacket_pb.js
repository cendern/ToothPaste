// source: toothpacket.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {missingRequire} reports error on implicit type usages.
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!
/* eslint-disable */
// @ts-nocheck

var jspb = require('google-protobuf');
var goog = jspb;
var global =
    (typeof globalThis !== 'undefined' && globalThis) ||
    (typeof window !== 'undefined' && window) ||
    (typeof global !== 'undefined' && global) ||
    (typeof self !== 'undefined' && self) ||
    (function () { return this; }).call(null) ||
    Function('return this')();

goog.exportSymbol('proto.toothpaste.ConsumerControlPacket', null, global);
goog.exportSymbol('proto.toothpaste.DataPacket', null, global);
goog.exportSymbol('proto.toothpaste.DataPacket.PacketID', null, global);
goog.exportSymbol('proto.toothpaste.EncryptedData', null, global);
goog.exportSymbol('proto.toothpaste.EncryptedData.PacketType', null, global);
goog.exportSymbol('proto.toothpaste.EncryptedData.PacketdataCase', null, global);
goog.exportSymbol('proto.toothpaste.Frame', null, global);
goog.exportSymbol('proto.toothpaste.KeyboardPacket', null, global);
goog.exportSymbol('proto.toothpaste.KeycodePacket', null, global);
goog.exportSymbol('proto.toothpaste.MousePacket', null, global);
goog.exportSymbol('proto.toothpaste.NotificationPacket', null, global);
goog.exportSymbol('proto.toothpaste.NotificationPacket.AuthStatus', null, global);
goog.exportSymbol('proto.toothpaste.NotificationPacket.NotificationType', null, global);
goog.exportSymbol('proto.toothpaste.RenamePacket', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.toothpaste.DataPacket = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.toothpaste.DataPacket, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.toothpaste.DataPacket.displayName = 'proto.toothpaste.DataPacket';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.toothpaste.EncryptedData = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.toothpaste.EncryptedData.oneofGroups_);
};
goog.inherits(proto.toothpaste.EncryptedData, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.toothpaste.EncryptedData.displayName = 'proto.toothpaste.EncryptedData';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.toothpaste.KeyboardPacket = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.toothpaste.KeyboardPacket, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.toothpaste.KeyboardPacket.displayName = 'proto.toothpaste.KeyboardPacket';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.toothpaste.RenamePacket = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.toothpaste.RenamePacket, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.toothpaste.RenamePacket.displayName = 'proto.toothpaste.RenamePacket';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.toothpaste.KeycodePacket = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.toothpaste.KeycodePacket, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.toothpaste.KeycodePacket.displayName = 'proto.toothpaste.KeycodePacket';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.toothpaste.Frame = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.toothpaste.Frame, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.toothpaste.Frame.displayName = 'proto.toothpaste.Frame';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.toothpaste.MousePacket = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.toothpaste.MousePacket.repeatedFields_, null);
};
goog.inherits(proto.toothpaste.MousePacket, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.toothpaste.MousePacket.displayName = 'proto.toothpaste.MousePacket';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.toothpaste.ConsumerControlPacket = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.toothpaste.ConsumerControlPacket.repeatedFields_, null);
};
goog.inherits(proto.toothpaste.ConsumerControlPacket, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.toothpaste.ConsumerControlPacket.displayName = 'proto.toothpaste.ConsumerControlPacket';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.toothpaste.NotificationPacket = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.toothpaste.NotificationPacket, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.toothpaste.NotificationPacket.displayName = 'proto.toothpaste.NotificationPacket';
}



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.toothpaste.DataPacket.prototype.toObject = function(opt_includeInstance) {
  return proto.toothpaste.DataPacket.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.toothpaste.DataPacket} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.toothpaste.DataPacket.toObject = function(includeInstance, msg) {
  var f, obj = {
packetid: jspb.Message.getFieldWithDefault(msg, 1, 0),
packetnumber: jspb.Message.getFieldWithDefault(msg, 2, 0),
totalpackets: jspb.Message.getFieldWithDefault(msg, 3, 0),
slowmode: jspb.Message.getBooleanFieldWithDefault(msg, 4, false),
iv: msg.getIv_asB64(),
datalen: jspb.Message.getFieldWithDefault(msg, 6, 0),
encrypteddata: msg.getEncrypteddata_asB64(),
tag: msg.getTag_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.toothpaste.DataPacket}
 */
proto.toothpaste.DataPacket.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.toothpaste.DataPacket;
  return proto.toothpaste.DataPacket.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.toothpaste.DataPacket} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.toothpaste.DataPacket}
 */
proto.toothpaste.DataPacket.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.toothpaste.DataPacket.PacketID} */ (reader.readEnum());
      msg.setPacketid(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPacketnumber(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setTotalpackets(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSlowmode(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setIv(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setDatalen(value);
      break;
    case 7:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setEncrypteddata(value);
      break;
    case 8:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTag(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.toothpaste.DataPacket.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.toothpaste.DataPacket.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.toothpaste.DataPacket} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.toothpaste.DataPacket.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPacketid();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getPacketnumber();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getTotalpackets();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = message.getSlowmode();
  if (f) {
    writer.writeBool(
      4,
      f
    );
  }
  f = message.getIv_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      5,
      f
    );
  }
  f = message.getDatalen();
  if (f !== 0) {
    writer.writeUint32(
      6,
      f
    );
  }
  f = message.getEncrypteddata_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      7,
      f
    );
  }
  f = message.getTag_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      8,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.toothpaste.DataPacket.PacketID = {
  DATA_PACKET: 0,
  AUTH_PACKET: 1
};

/**
 * optional PacketID packetID = 1;
 * @return {!proto.toothpaste.DataPacket.PacketID}
 */
proto.toothpaste.DataPacket.prototype.getPacketid = function() {
  return /** @type {!proto.toothpaste.DataPacket.PacketID} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.toothpaste.DataPacket.PacketID} value
 * @return {!proto.toothpaste.DataPacket} returns this
 */
proto.toothpaste.DataPacket.prototype.setPacketid = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional uint32 packetNumber = 2;
 * @return {number}
 */
proto.toothpaste.DataPacket.prototype.getPacketnumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.toothpaste.DataPacket} returns this
 */
proto.toothpaste.DataPacket.prototype.setPacketnumber = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional uint32 totalPackets = 3;
 * @return {number}
 */
proto.toothpaste.DataPacket.prototype.getTotalpackets = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.toothpaste.DataPacket} returns this
 */
proto.toothpaste.DataPacket.prototype.setTotalpackets = function(value) {
  return jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * optional bool slowMode = 4;
 * @return {boolean}
 */
proto.toothpaste.DataPacket.prototype.getSlowmode = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 4, false));
};


/**
 * @param {boolean} value
 * @return {!proto.toothpaste.DataPacket} returns this
 */
proto.toothpaste.DataPacket.prototype.setSlowmode = function(value) {
  return jspb.Message.setProto3BooleanField(this, 4, value);
};


/**
 * optional bytes iv = 5;
 * @return {!(string|Uint8Array)}
 */
proto.toothpaste.DataPacket.prototype.getIv = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * optional bytes iv = 5;
 * This is a type-conversion wrapper around `getIv()`
 * @return {string}
 */
proto.toothpaste.DataPacket.prototype.getIv_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getIv()));
};


/**
 * optional bytes iv = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getIv()`
 * @return {!Uint8Array}
 */
proto.toothpaste.DataPacket.prototype.getIv_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getIv()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.toothpaste.DataPacket} returns this
 */
proto.toothpaste.DataPacket.prototype.setIv = function(value) {
  return jspb.Message.setProto3BytesField(this, 5, value);
};


/**
 * optional uint32 dataLen = 6;
 * @return {number}
 */
proto.toothpaste.DataPacket.prototype.getDatalen = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/**
 * @param {number} value
 * @return {!proto.toothpaste.DataPacket} returns this
 */
proto.toothpaste.DataPacket.prototype.setDatalen = function(value) {
  return jspb.Message.setProto3IntField(this, 6, value);
};


/**
 * optional bytes encryptedData = 7;
 * @return {!(string|Uint8Array)}
 */
proto.toothpaste.DataPacket.prototype.getEncrypteddata = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 7, ""));
};


/**
 * optional bytes encryptedData = 7;
 * This is a type-conversion wrapper around `getEncrypteddata()`
 * @return {string}
 */
proto.toothpaste.DataPacket.prototype.getEncrypteddata_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getEncrypteddata()));
};


/**
 * optional bytes encryptedData = 7;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getEncrypteddata()`
 * @return {!Uint8Array}
 */
proto.toothpaste.DataPacket.prototype.getEncrypteddata_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getEncrypteddata()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.toothpaste.DataPacket} returns this
 */
proto.toothpaste.DataPacket.prototype.setEncrypteddata = function(value) {
  return jspb.Message.setProto3BytesField(this, 7, value);
};


/**
 * optional bytes tag = 8;
 * @return {!(string|Uint8Array)}
 */
proto.toothpaste.DataPacket.prototype.getTag = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 8, ""));
};


/**
 * optional bytes tag = 8;
 * This is a type-conversion wrapper around `getTag()`
 * @return {string}
 */
proto.toothpaste.DataPacket.prototype.getTag_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTag()));
};


/**
 * optional bytes tag = 8;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTag()`
 * @return {!Uint8Array}
 */
proto.toothpaste.DataPacket.prototype.getTag_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTag()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.toothpaste.DataPacket} returns this
 */
proto.toothpaste.DataPacket.prototype.setTag = function(value) {
  return jspb.Message.setProto3BytesField(this, 8, value);
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.toothpaste.EncryptedData.oneofGroups_ = [[2,3,4,5,6]];

/**
 * @enum {number}
 */
proto.toothpaste.EncryptedData.PacketdataCase = {
  PACKETDATA_NOT_SET: 0,
  KEYBOARDPACKET: 2,
  KEYCODEPACKET: 3,
  MOUSEPACKET: 4,
  RENAMEPACKET: 5,
  CONSUMERCONTROLPACKET: 6
};

/**
 * @return {proto.toothpaste.EncryptedData.PacketdataCase}
 */
proto.toothpaste.EncryptedData.prototype.getPacketdataCase = function() {
  return /** @type {proto.toothpaste.EncryptedData.PacketdataCase} */(jspb.Message.computeOneofCase(this, proto.toothpaste.EncryptedData.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.toothpaste.EncryptedData.prototype.toObject = function(opt_includeInstance) {
  return proto.toothpaste.EncryptedData.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.toothpaste.EncryptedData} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.toothpaste.EncryptedData.toObject = function(includeInstance, msg) {
  var f, obj = {
packettype: jspb.Message.getFieldWithDefault(msg, 1, 0),
keyboardpacket: (f = msg.getKeyboardpacket()) && proto.toothpaste.KeyboardPacket.toObject(includeInstance, f),
keycodepacket: (f = msg.getKeycodepacket()) && proto.toothpaste.KeycodePacket.toObject(includeInstance, f),
mousepacket: (f = msg.getMousepacket()) && proto.toothpaste.MousePacket.toObject(includeInstance, f),
renamepacket: (f = msg.getRenamepacket()) && proto.toothpaste.RenamePacket.toObject(includeInstance, f),
consumercontrolpacket: (f = msg.getConsumercontrolpacket()) && proto.toothpaste.ConsumerControlPacket.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.toothpaste.EncryptedData}
 */
proto.toothpaste.EncryptedData.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.toothpaste.EncryptedData;
  return proto.toothpaste.EncryptedData.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.toothpaste.EncryptedData} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.toothpaste.EncryptedData}
 */
proto.toothpaste.EncryptedData.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.toothpaste.EncryptedData.PacketType} */ (reader.readEnum());
      msg.setPackettype(value);
      break;
    case 2:
      var value = new proto.toothpaste.KeyboardPacket;
      reader.readMessage(value,proto.toothpaste.KeyboardPacket.deserializeBinaryFromReader);
      msg.setKeyboardpacket(value);
      break;
    case 3:
      var value = new proto.toothpaste.KeycodePacket;
      reader.readMessage(value,proto.toothpaste.KeycodePacket.deserializeBinaryFromReader);
      msg.setKeycodepacket(value);
      break;
    case 4:
      var value = new proto.toothpaste.MousePacket;
      reader.readMessage(value,proto.toothpaste.MousePacket.deserializeBinaryFromReader);
      msg.setMousepacket(value);
      break;
    case 5:
      var value = new proto.toothpaste.RenamePacket;
      reader.readMessage(value,proto.toothpaste.RenamePacket.deserializeBinaryFromReader);
      msg.setRenamepacket(value);
      break;
    case 6:
      var value = new proto.toothpaste.ConsumerControlPacket;
      reader.readMessage(value,proto.toothpaste.ConsumerControlPacket.deserializeBinaryFromReader);
      msg.setConsumercontrolpacket(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.toothpaste.EncryptedData.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.toothpaste.EncryptedData.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.toothpaste.EncryptedData} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.toothpaste.EncryptedData.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPackettype();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getKeyboardpacket();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.toothpaste.KeyboardPacket.serializeBinaryToWriter
    );
  }
  f = message.getKeycodepacket();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.toothpaste.KeycodePacket.serializeBinaryToWriter
    );
  }
  f = message.getMousepacket();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.toothpaste.MousePacket.serializeBinaryToWriter
    );
  }
  f = message.getRenamepacket();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.toothpaste.RenamePacket.serializeBinaryToWriter
    );
  }
  f = message.getConsumercontrolpacket();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.toothpaste.ConsumerControlPacket.serializeBinaryToWriter
    );
  }
};


/**
 * @enum {number}
 */
proto.toothpaste.EncryptedData.PacketType = {
  KEYBOARD_STRING: 0,
  KEYBOARD_KEYCODE: 1,
  MOUSE: 2,
  RENAME: 3,
  CONSUMER_CONTROL: 4,
  COMPOSITE: 5
};

/**
 * optional PacketType packetType = 1;
 * @return {!proto.toothpaste.EncryptedData.PacketType}
 */
proto.toothpaste.EncryptedData.prototype.getPackettype = function() {
  return /** @type {!proto.toothpaste.EncryptedData.PacketType} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.toothpaste.EncryptedData.PacketType} value
 * @return {!proto.toothpaste.EncryptedData} returns this
 */
proto.toothpaste.EncryptedData.prototype.setPackettype = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional KeyboardPacket keyboardPacket = 2;
 * @return {?proto.toothpaste.KeyboardPacket}
 */
proto.toothpaste.EncryptedData.prototype.getKeyboardpacket = function() {
  return /** @type{?proto.toothpaste.KeyboardPacket} */ (
    jspb.Message.getWrapperField(this, proto.toothpaste.KeyboardPacket, 2));
};


/**
 * @param {?proto.toothpaste.KeyboardPacket|undefined} value
 * @return {!proto.toothpaste.EncryptedData} returns this
*/
proto.toothpaste.EncryptedData.prototype.setKeyboardpacket = function(value) {
  return jspb.Message.setOneofWrapperField(this, 2, proto.toothpaste.EncryptedData.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.toothpaste.EncryptedData} returns this
 */
proto.toothpaste.EncryptedData.prototype.clearKeyboardpacket = function() {
  return this.setKeyboardpacket(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.toothpaste.EncryptedData.prototype.hasKeyboardpacket = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional KeycodePacket keycodePacket = 3;
 * @return {?proto.toothpaste.KeycodePacket}
 */
proto.toothpaste.EncryptedData.prototype.getKeycodepacket = function() {
  return /** @type{?proto.toothpaste.KeycodePacket} */ (
    jspb.Message.getWrapperField(this, proto.toothpaste.KeycodePacket, 3));
};


/**
 * @param {?proto.toothpaste.KeycodePacket|undefined} value
 * @return {!proto.toothpaste.EncryptedData} returns this
*/
proto.toothpaste.EncryptedData.prototype.setKeycodepacket = function(value) {
  return jspb.Message.setOneofWrapperField(this, 3, proto.toothpaste.EncryptedData.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.toothpaste.EncryptedData} returns this
 */
proto.toothpaste.EncryptedData.prototype.clearKeycodepacket = function() {
  return this.setKeycodepacket(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.toothpaste.EncryptedData.prototype.hasKeycodepacket = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional MousePacket mousePacket = 4;
 * @return {?proto.toothpaste.MousePacket}
 */
proto.toothpaste.EncryptedData.prototype.getMousepacket = function() {
  return /** @type{?proto.toothpaste.MousePacket} */ (
    jspb.Message.getWrapperField(this, proto.toothpaste.MousePacket, 4));
};


/**
 * @param {?proto.toothpaste.MousePacket|undefined} value
 * @return {!proto.toothpaste.EncryptedData} returns this
*/
proto.toothpaste.EncryptedData.prototype.setMousepacket = function(value) {
  return jspb.Message.setOneofWrapperField(this, 4, proto.toothpaste.EncryptedData.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.toothpaste.EncryptedData} returns this
 */
proto.toothpaste.EncryptedData.prototype.clearMousepacket = function() {
  return this.setMousepacket(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.toothpaste.EncryptedData.prototype.hasMousepacket = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional RenamePacket renamePacket = 5;
 * @return {?proto.toothpaste.RenamePacket}
 */
proto.toothpaste.EncryptedData.prototype.getRenamepacket = function() {
  return /** @type{?proto.toothpaste.RenamePacket} */ (
    jspb.Message.getWrapperField(this, proto.toothpaste.RenamePacket, 5));
};


/**
 * @param {?proto.toothpaste.RenamePacket|undefined} value
 * @return {!proto.toothpaste.EncryptedData} returns this
*/
proto.toothpaste.EncryptedData.prototype.setRenamepacket = function(value) {
  return jspb.Message.setOneofWrapperField(this, 5, proto.toothpaste.EncryptedData.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.toothpaste.EncryptedData} returns this
 */
proto.toothpaste.EncryptedData.prototype.clearRenamepacket = function() {
  return this.setRenamepacket(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.toothpaste.EncryptedData.prototype.hasRenamepacket = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional ConsumerControlPacket consumerControlPacket = 6;
 * @return {?proto.toothpaste.ConsumerControlPacket}
 */
proto.toothpaste.EncryptedData.prototype.getConsumercontrolpacket = function() {
  return /** @type{?proto.toothpaste.ConsumerControlPacket} */ (
    jspb.Message.getWrapperField(this, proto.toothpaste.ConsumerControlPacket, 6));
};


/**
 * @param {?proto.toothpaste.ConsumerControlPacket|undefined} value
 * @return {!proto.toothpaste.EncryptedData} returns this
*/
proto.toothpaste.EncryptedData.prototype.setConsumercontrolpacket = function(value) {
  return jspb.Message.setOneofWrapperField(this, 6, proto.toothpaste.EncryptedData.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.toothpaste.EncryptedData} returns this
 */
proto.toothpaste.EncryptedData.prototype.clearConsumercontrolpacket = function() {
  return this.setConsumercontrolpacket(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.toothpaste.EncryptedData.prototype.hasConsumercontrolpacket = function() {
  return jspb.Message.getField(this, 6) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.toothpaste.KeyboardPacket.prototype.toObject = function(opt_includeInstance) {
  return proto.toothpaste.KeyboardPacket.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.toothpaste.KeyboardPacket} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.toothpaste.KeyboardPacket.toObject = function(includeInstance, msg) {
  var f, obj = {
message: jspb.Message.getFieldWithDefault(msg, 1, ""),
length: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.toothpaste.KeyboardPacket}
 */
proto.toothpaste.KeyboardPacket.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.toothpaste.KeyboardPacket;
  return proto.toothpaste.KeyboardPacket.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.toothpaste.KeyboardPacket} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.toothpaste.KeyboardPacket}
 */
proto.toothpaste.KeyboardPacket.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMessage(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setLength(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.toothpaste.KeyboardPacket.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.toothpaste.KeyboardPacket.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.toothpaste.KeyboardPacket} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.toothpaste.KeyboardPacket.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMessage();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getLength();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
};


/**
 * optional string message = 1;
 * @return {string}
 */
proto.toothpaste.KeyboardPacket.prototype.getMessage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.toothpaste.KeyboardPacket} returns this
 */
proto.toothpaste.KeyboardPacket.prototype.setMessage = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional uint32 length = 2;
 * @return {number}
 */
proto.toothpaste.KeyboardPacket.prototype.getLength = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.toothpaste.KeyboardPacket} returns this
 */
proto.toothpaste.KeyboardPacket.prototype.setLength = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.toothpaste.RenamePacket.prototype.toObject = function(opt_includeInstance) {
  return proto.toothpaste.RenamePacket.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.toothpaste.RenamePacket} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.toothpaste.RenamePacket.toObject = function(includeInstance, msg) {
  var f, obj = {
message: jspb.Message.getFieldWithDefault(msg, 1, ""),
length: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.toothpaste.RenamePacket}
 */
proto.toothpaste.RenamePacket.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.toothpaste.RenamePacket;
  return proto.toothpaste.RenamePacket.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.toothpaste.RenamePacket} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.toothpaste.RenamePacket}
 */
proto.toothpaste.RenamePacket.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMessage(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setLength(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.toothpaste.RenamePacket.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.toothpaste.RenamePacket.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.toothpaste.RenamePacket} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.toothpaste.RenamePacket.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMessage();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getLength();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
};


/**
 * optional string message = 1;
 * @return {string}
 */
proto.toothpaste.RenamePacket.prototype.getMessage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.toothpaste.RenamePacket} returns this
 */
proto.toothpaste.RenamePacket.prototype.setMessage = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional uint32 length = 2;
 * @return {number}
 */
proto.toothpaste.RenamePacket.prototype.getLength = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.toothpaste.RenamePacket} returns this
 */
proto.toothpaste.RenamePacket.prototype.setLength = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.toothpaste.KeycodePacket.prototype.toObject = function(opt_includeInstance) {
  return proto.toothpaste.KeycodePacket.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.toothpaste.KeycodePacket} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.toothpaste.KeycodePacket.toObject = function(includeInstance, msg) {
  var f, obj = {
code: msg.getCode_asB64(),
length: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.toothpaste.KeycodePacket}
 */
proto.toothpaste.KeycodePacket.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.toothpaste.KeycodePacket;
  return proto.toothpaste.KeycodePacket.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.toothpaste.KeycodePacket} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.toothpaste.KeycodePacket}
 */
proto.toothpaste.KeycodePacket.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setCode(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setLength(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.toothpaste.KeycodePacket.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.toothpaste.KeycodePacket.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.toothpaste.KeycodePacket} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.toothpaste.KeycodePacket.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCode_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getLength();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
};


/**
 * optional bytes code = 1;
 * @return {!(string|Uint8Array)}
 */
proto.toothpaste.KeycodePacket.prototype.getCode = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes code = 1;
 * This is a type-conversion wrapper around `getCode()`
 * @return {string}
 */
proto.toothpaste.KeycodePacket.prototype.getCode_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getCode()));
};


/**
 * optional bytes code = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getCode()`
 * @return {!Uint8Array}
 */
proto.toothpaste.KeycodePacket.prototype.getCode_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getCode()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.toothpaste.KeycodePacket} returns this
 */
proto.toothpaste.KeycodePacket.prototype.setCode = function(value) {
  return jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional uint32 length = 2;
 * @return {number}
 */
proto.toothpaste.KeycodePacket.prototype.getLength = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.toothpaste.KeycodePacket} returns this
 */
proto.toothpaste.KeycodePacket.prototype.setLength = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.toothpaste.Frame.prototype.toObject = function(opt_includeInstance) {
  return proto.toothpaste.Frame.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.toothpaste.Frame} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.toothpaste.Frame.toObject = function(includeInstance, msg) {
  var f, obj = {
x: jspb.Message.getFieldWithDefault(msg, 1, 0),
y: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.toothpaste.Frame}
 */
proto.toothpaste.Frame.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.toothpaste.Frame;
  return proto.toothpaste.Frame.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.toothpaste.Frame} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.toothpaste.Frame}
 */
proto.toothpaste.Frame.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setX(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setY(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.toothpaste.Frame.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.toothpaste.Frame.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.toothpaste.Frame} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.toothpaste.Frame.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getX();
  if (f !== 0) {
    writer.writeInt32(
      1,
      f
    );
  }
  f = message.getY();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
};


/**
 * optional int32 x = 1;
 * @return {number}
 */
proto.toothpaste.Frame.prototype.getX = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.toothpaste.Frame} returns this
 */
proto.toothpaste.Frame.prototype.setX = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional int32 y = 2;
 * @return {number}
 */
proto.toothpaste.Frame.prototype.getY = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.toothpaste.Frame} returns this
 */
proto.toothpaste.Frame.prototype.setY = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.toothpaste.MousePacket.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.toothpaste.MousePacket.prototype.toObject = function(opt_includeInstance) {
  return proto.toothpaste.MousePacket.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.toothpaste.MousePacket} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.toothpaste.MousePacket.toObject = function(includeInstance, msg) {
  var f, obj = {
numFrames: jspb.Message.getFieldWithDefault(msg, 1, 0),
framesList: jspb.Message.toObjectList(msg.getFramesList(),
    proto.toothpaste.Frame.toObject, includeInstance),
lClick: jspb.Message.getFieldWithDefault(msg, 3, 0),
rClick: jspb.Message.getFieldWithDefault(msg, 4, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.toothpaste.MousePacket}
 */
proto.toothpaste.MousePacket.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.toothpaste.MousePacket;
  return proto.toothpaste.MousePacket.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.toothpaste.MousePacket} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.toothpaste.MousePacket}
 */
proto.toothpaste.MousePacket.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setNumFrames(value);
      break;
    case 2:
      var value = new proto.toothpaste.Frame;
      reader.readMessage(value,proto.toothpaste.Frame.deserializeBinaryFromReader);
      msg.addFrames(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setLClick(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setRClick(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.toothpaste.MousePacket.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.toothpaste.MousePacket.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.toothpaste.MousePacket} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.toothpaste.MousePacket.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNumFrames();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getFramesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.toothpaste.Frame.serializeBinaryToWriter
    );
  }
  f = message.getLClick();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = message.getRClick();
  if (f !== 0) {
    writer.writeInt32(
      4,
      f
    );
  }
};


/**
 * optional uint32 num_frames = 1;
 * @return {number}
 */
proto.toothpaste.MousePacket.prototype.getNumFrames = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.toothpaste.MousePacket} returns this
 */
proto.toothpaste.MousePacket.prototype.setNumFrames = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * repeated Frame frames = 2;
 * @return {!Array<!proto.toothpaste.Frame>}
 */
proto.toothpaste.MousePacket.prototype.getFramesList = function() {
  return /** @type{!Array<!proto.toothpaste.Frame>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.toothpaste.Frame, 2));
};


/**
 * @param {!Array<!proto.toothpaste.Frame>} value
 * @return {!proto.toothpaste.MousePacket} returns this
*/
proto.toothpaste.MousePacket.prototype.setFramesList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.toothpaste.Frame=} opt_value
 * @param {number=} opt_index
 * @return {!proto.toothpaste.Frame}
 */
proto.toothpaste.MousePacket.prototype.addFrames = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.toothpaste.Frame, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.toothpaste.MousePacket} returns this
 */
proto.toothpaste.MousePacket.prototype.clearFramesList = function() {
  return this.setFramesList([]);
};


/**
 * optional int32 l_click = 3;
 * @return {number}
 */
proto.toothpaste.MousePacket.prototype.getLClick = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.toothpaste.MousePacket} returns this
 */
proto.toothpaste.MousePacket.prototype.setLClick = function(value) {
  return jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * optional int32 r_click = 4;
 * @return {number}
 */
proto.toothpaste.MousePacket.prototype.getRClick = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.toothpaste.MousePacket} returns this
 */
proto.toothpaste.MousePacket.prototype.setRClick = function(value) {
  return jspb.Message.setProto3IntField(this, 4, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.toothpaste.ConsumerControlPacket.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.toothpaste.ConsumerControlPacket.prototype.toObject = function(opt_includeInstance) {
  return proto.toothpaste.ConsumerControlPacket.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.toothpaste.ConsumerControlPacket} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.toothpaste.ConsumerControlPacket.toObject = function(includeInstance, msg) {
  var f, obj = {
codeList: (f = jspb.Message.getRepeatedField(msg, 1)) == null ? undefined : f,
length: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.toothpaste.ConsumerControlPacket}
 */
proto.toothpaste.ConsumerControlPacket.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.toothpaste.ConsumerControlPacket;
  return proto.toothpaste.ConsumerControlPacket.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.toothpaste.ConsumerControlPacket} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.toothpaste.ConsumerControlPacket}
 */
proto.toothpaste.ConsumerControlPacket.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var values = /** @type {!Array<number>} */ (reader.isDelimited() ? reader.readPackedUint32() : [reader.readUint32()]);
      for (var i = 0; i < values.length; i++) {
        msg.addCode(values[i]);
      }
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setLength(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.toothpaste.ConsumerControlPacket.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.toothpaste.ConsumerControlPacket.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.toothpaste.ConsumerControlPacket} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.toothpaste.ConsumerControlPacket.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCodeList();
  if (f.length > 0) {
    writer.writePackedUint32(
      1,
      f
    );
  }
  f = message.getLength();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
};


/**
 * repeated uint32 code = 1;
 * @return {!Array<number>}
 */
proto.toothpaste.ConsumerControlPacket.prototype.getCodeList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 1));
};


/**
 * @param {!Array<number>} value
 * @return {!proto.toothpaste.ConsumerControlPacket} returns this
 */
proto.toothpaste.ConsumerControlPacket.prototype.setCodeList = function(value) {
  return jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {number} value
 * @param {number=} opt_index
 * @return {!proto.toothpaste.ConsumerControlPacket} returns this
 */
proto.toothpaste.ConsumerControlPacket.prototype.addCode = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.toothpaste.ConsumerControlPacket} returns this
 */
proto.toothpaste.ConsumerControlPacket.prototype.clearCodeList = function() {
  return this.setCodeList([]);
};


/**
 * optional uint32 length = 2;
 * @return {number}
 */
proto.toothpaste.ConsumerControlPacket.prototype.getLength = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.toothpaste.ConsumerControlPacket} returns this
 */
proto.toothpaste.ConsumerControlPacket.prototype.setLength = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.toothpaste.NotificationPacket.prototype.toObject = function(opt_includeInstance) {
  return proto.toothpaste.NotificationPacket.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.toothpaste.NotificationPacket} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.toothpaste.NotificationPacket.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.toothpaste.NotificationPacket}
 */
proto.toothpaste.NotificationPacket.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.toothpaste.NotificationPacket;
  return proto.toothpaste.NotificationPacket.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.toothpaste.NotificationPacket} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.toothpaste.NotificationPacket}
 */
proto.toothpaste.NotificationPacket.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.toothpaste.NotificationPacket.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.toothpaste.NotificationPacket.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.toothpaste.NotificationPacket} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.toothpaste.NotificationPacket.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};


/**
 * @enum {number}
 */
proto.toothpaste.NotificationPacket.NotificationType = {
  KEEPALIVE: 0,
  RECV_READY: 1,
  RECV_NOT_READY: 2
};

/**
 * @enum {number}
 */
proto.toothpaste.NotificationPacket.AuthStatus = {
  AUTH_FAILED: 0,
  AUTH_SUCCESS: 1
};

goog.object.extend(exports, proto.toothpaste);
